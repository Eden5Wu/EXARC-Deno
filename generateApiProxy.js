// generateApiProxy.js (for Deno)

import {
    join as pathJoin,
    dirname as pathDirname,
    fromFileUrl
} from 'https://deno.land/std@0.224.0/path/mod.ts';

const __dirname = pathDirname(fromFileUrl(import.meta.url));

// 定義生成檔案的輸出路徑
const OUTPUT_PATH = pathJoin(__dirname, 'public', 'ajax', 'apiProxy.js');
// apiExecutor.js 相對於 apiProxy.js 的路徑
const API_EXECUTOR_RELATIVE_PATH = './apiExecutor.js';

/**
 * @private
 * 處理 API 呼叫的通用邏輯，包括錯誤處理。
 * 這個函數會被嵌入到生成的 apiProxy.js 中。
 * @param {Function} apiCallFn - 實際執行 API 請求的函數 (e.g., api.get, api.post)。
 * @param {string} endpoint - API 端點名稱或已構建的完整路徑（例如：'echomsg' 或 'users/123/orders'）。
 * @param {any} [dataOrQueryParams] - 請求數據 (用於 POST/PUT 請求主體) 或查詢參數 (用於 GET/DELETE 請求)。
 * @returns {Promise<Object|string>} 成功時解析為伺服器回應的 JSON 物件或文本。
 * @throws {Error} 如果請求失敗或伺服器返回非 2xx 狀態碼。
 */
const handleApiCallFunctionContent = `
async function handleApiCall(apiCallFn, endpoint, dataOrQueryParams = null) {
    try {
        // api.get, api.delete 期望 endpoint 和 queryParams
        // api.post, api.put 期望 endpoint 和 data
        const response = (apiCallFn.name === 'get' || apiCallFn.name === 'delete')
            ? await apiCallFn(endpoint, dataOrQueryParams) // dataOrQueryParams here is queryParams
            : await apiCallFn(endpoint, dataOrQueryParams); // dataOrQueryParams here is data

        console.log(\`\${endpoint} 成功:\`, response);
        return response;
    } catch (error) {
        console.error(\`\${endpoint} 失敗:\`, error);
        throw error; // 將錯誤重新拋出，讓上層呼叫者處理顯示邏輯
    }
}
`;

/**
 * 生成 apiProxy.js 檔案的函數。
 * 此函數會動態檢查 Express 應用程式的路由，並據此生成前端代理。
 *
 * @param {import('express').Application} app - Express 應用程式實例。
 * // apiMetadata 參數已移除，所有資訊將從 Express 路由本身推斷
 */
export function generateApiProxyFile(app) { // <-- apiMetadata 參數已移除
    let proxyContent = `// This file is auto-generated by the server startup script.\n`;
    proxyContent += `// Do not edit this file directly in development mode.\n\n`;
    proxyContent += `import { api } from '${API_EXECUTOR_RELATIVE_PATH}';\n\n`;
    proxyContent += `/**\n * @private\n * 處理 API 呼叫的通用邏輯，包括錯誤處理。\n */\n`;
    proxyContent += handleApiCallFunctionContent;
    proxyContent += `export const apiProxy = {\n`;

    // 遍歷 Express 路由器堆疊以查找路由
    app._router.stack.forEach(layer => {
        if (layer.route) {
            const route = layer.route;
            const fullPath = route.path; // e.g., '/api/users/:userId/orders/:orderId'

            if (!fullPath.startsWith('/api/')) {
                return;
            }

            // Remove '/api/' prefix from path for endpoint name/path that apiExecutor expects
            const endpointBase = fullPath.substring('/api/'.length); // e.g., 'users/:userId/orders/:orderId'

            // mappedInfo will no longer be used as apiMetadata is gone.
            // All info will be derived or use defaults.

            for (const method in route.methods) {
                if (route.methods[method]) {
                    const httpMethod = method.toLowerCase();
                    let paramsDeclaration = '';    // e.g., 'userId, orderId, queryParams = {}'
                    let functionBodyContent = '';  // Content inside the generated async function
                    
                    // JSDoc Description: Now purely generic or derived from route structure
                    let jsdocDescription = `呼叫 ${httpMethod.toUpperCase()} /${endpointBase} API。`;
                    let jsdocParams = '';          // e.g., '@param {string} userId'

                    // Determine the name of the proxy function (without HTTP verb prefix)
                    let currentProxyMethodName;
                    // Clean endpointBase: remove path params, replace slashes with empty string, then convert to camelCase
                    // e.g., 'users/:userId/orders' -> 'usersorders' -> 'usersOrders'
                    let baseName = endpointBase.replace(/:([a-zA-Z0-9_]+)/g, '').replace(/\//g, '');
                    
                    // Convert kebab-case or any remaining dashes to camelCase
                    baseName = baseName.replace(/-([a-z])/g, (match, p1) => p1.toUpperCase());
                    
                    // Ensure the first letter is lowercase for method naming conventions
                    currentProxyMethodName = baseName.charAt(0).toLowerCase() + baseName.slice(1);
                    
                    // Fallback for very simple paths like ":id" or empty string after cleanup
                    if (!currentProxyMethodName) { // if baseName was empty
                         const firstPathParam = endpointBase.match(/:([a-zA-Z0-9_]+)/);
                         if (firstPathParam) {
                            // If endpoint is just '/:id', use the param name itself (lowercase first letter)
                            currentProxyMethodName = firstPathParam[1].charAt(0).toLowerCase() + firstPathParam[1].slice(1);
                         } else {
                            // Fallback for root path (e.g., '/') or completely empty base
                            currentProxyMethodName = 'rootEndpoint'; 
                         }
                    }


                    // --- Handle GET and DELETE requests with path and query parameters ---
                    if (httpMethod === 'get' || httpMethod === 'delete') {
                        // Extract path parameters from the endpointBase (e.g., 'users/:userId/orders/:orderId')
                        const pathParamRegex = /:([a-zA-Z0-9_]+)/g;
                        const extractedPathParams = [];
                        let pathMatch;
                        // Use endpointBase for regex execution here
                        while ((pathMatch = pathParamRegex.exec(endpointBase)) !== null) {
                            extractedPathParams.push(pathMatch[1]);
                        }

                        // Build the function signature's parameter list
                        if (extractedPathParams.length > 0) {
                            paramsDeclaration = extractedPathParams.join(', ');
                            jsdocParams += extractedPathParams.map(p => `     * @param {string} ${p} - URL 路徑參數：${p}。\n`).join('');
                        }

                        // Always add optional queryParams object for GET/DELETE (convention)
                        if (paramsDeclaration) {
                            paramsDeclaration += ', ';
                        }
                        paramsDeclaration += 'queryParams = {}';
                        jsdocParams += `     * @param {Object} [queryParams] - 選填：額外的 URL 查詢參數物件。\n`;

                        // Construct the endpoint path to be passed to api.get
                        // Example: 'users/:userId' -> 'users/${userId}'
                        const endpointPathEvaluated = endpointBase.replace(pathParamRegex, (match, p) => `\${${p}}`);
                        
                        // Call handleApiCall, passing the evaluated endpoint path and queryParams
                        functionBodyContent = `        const endpoint = \`${endpointPathEvaluated}\`;\n`;
                        // Ensure queryParams is an object before passing, even if it's passed as null or ''
                        functionBodyContent += `        const finalQueryParams = (typeof queryParams === 'object' && queryParams !== null) ? queryParams : {};\n`;
                        functionBodyContent += `        return handleApiCall(api.${httpMethod}, endpoint, finalQueryParams);\n`;

                    } else { // --- Handle POST and PUT requests ---
                        // POST/PUT functions will now accept 'data' (for body) and 'queryParams'
                        let paramNameForBody = 'data'; 
                        let jsdocBodyType = 'Object'; // Default JSDoc type for body (assuming JSON object/array)

                        paramsDeclaration = paramNameForBody;
                        jsdocParams += `     * @param {${jsdocBodyType}} ${paramNameForBody} - 請求主體數據 (預期為 JSON 物件或陣列)。\n`;
                        
                        // Add queryParams for POST/PUT requests as well
                        paramsDeclaration += ', queryParams = {}';
                        jsdocParams += `     * @param {Object} [queryParams] - 選填：額外的 URL 查詢參數物件。\n`;

                        // Construct the final URL with query parameters for POST/PUT
                        functionBodyContent = `        const endpoint = '${endpointBase}';\n`;
                        functionBodyContent += `        const finalQueryParams = (typeof queryParams === 'object' && queryParams !== null) ? queryParams : {};\n`;
                        functionBodyContent += `        const queryString = new URLSearchParams(finalQueryParams).toString();\n`;
                        functionBodyContent += `        const finalUrl = queryString ? \`\${endpoint}?\${queryString}\` : endpoint;\n`;
                        functionBodyContent += `        return handleApiCall(api.${httpMethod}, finalUrl, ${paramNameForBody});\n`;
                    }

                    // Append the generated API method to proxyContent
                    proxyContent += `    /**\n`;
                    proxyContent += `     * ${jsdocDescription}\n`;
                    proxyContent += jsdocParams; // Includes @param from above logic
                    proxyContent += `     * @returns {Promise<Object|string>} 回應數據。\n`;
                    proxyContent += `     */\n`;
                    proxyContent += `    ${currentProxyMethodName}: async (${paramsDeclaration}) => {\n`;
                    proxyContent += functionBodyContent;
                    proxyContent += `    },\n\n`;
                }
            }
        }
    });

    proxyContent += `};\n`;

    // 將生成的內容寫入檔案
    Deno.writeTextFile(OUTPUT_PATH, proxyContent, {
        create: true,
        append: false
    })
    .then(() => {
        console.log(`[API Proxy 生成器] ${OUTPUT_PATH} 已成功生成。`);
    })
    .catch((error) => {
        console.error(`[API Proxy 生成器] 寫入檔案失敗:`, error);
    });
}
