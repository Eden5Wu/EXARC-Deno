// utils/generateApiProxy.ts

import type { Router } from "../deps.ts";

const OUTPUT_PATH = `${Deno.cwd()}/public/ajax/apiProxy.js`;
const API_MOD_PATH = `${Deno.cwd()}/api/mod.ts`;
const API_EXECUTOR_RELATIVE_PATH = "./apiExecutor.js";

/**
 * @private
 * 處理 API 呼叫的通用邏輯，會被嵌入到生成的 apiProxy.js 中。
 */
const handleApiCallFunctionContent = `
async function handleApiCall(apiCallFn, endpoint, data = null, queryParams = {}, accept = null) {
    try {
        let response;
        if (apiCallFn.name === 'get' || apiCallFn.name === 'delete') {
            response = await apiCallFn(endpoint, queryParams, accept);
        } else {
            response = await apiCallFn(endpoint, data, queryParams, accept);
        }
        console.log(\`\${endpoint} 成功:\`, response);
        return response;
    } catch (error) {
        console.error(\`\${endpoint} 失敗:\`, error);
        throw error;
    }
}
`;

/**
 * 從 Oak Router 實例中列出所有端點。
 */
function listEndpoints(router: Router) {
  const endpoints = [];
  for (const route of router) {
    endpoints.push({
      path: route.path,
      methods: Array.isArray(route.methods)
        ? route.methods.filter((m) => m !== "HEAD")
        : [],
    });
  }
  return endpoints;
}

/**
 * 從 sourceCode 中找出所有路由與對應的 JSDoc 註解。
 */
function extractAllRouteDocs(sourceCode: string): Record<string, string> {
  const pattern = /\/\*\*[^]*?\*\/\s*apiRouter\.(\w+)\(\s*["'](\/api\/[^"']+)["']/g;
  const result: Record<string, string> = {};
  let match;
  while ((match = pattern.exec(sourceCode)) !== null) {
    const jsdocBlock = match[0];
    const jsdocOnly = jsdocBlock.match(/\/\*\*[^]*?\*\//)?.[0]?.trim() ?? "";
    const method = match[1].toLowerCase();
    const path = match[2];
    result[`${method} ${path}`] = jsdocOnly;
  }
  return result;
}

/**
 * 生成 apiProxy.js 檔案的主函式。
 */
export async function generateApiProxyFile(router: Router) {
  const endpoints = listEndpoints(router);
  const apiModSource = await Deno.readTextFile(API_MOD_PATH);
  const routeDocsMap = extractAllRouteDocs(apiModSource);

  if (!endpoints.length) {
    console.warn("[API Proxy 生成器] ⚠ 無可用 API 路由。");
    return;
  }

  let proxyContent = `// This file is auto-generated by the server startup script.\n`;
  proxyContent += `// Do not edit this file directly in development mode.\n\n`;
  proxyContent += `import { api } from '${API_EXECUTOR_RELATIVE_PATH}';\n\n`;
  proxyContent += `/**\n * @private\n * 處理 API 呼叫的通用邏輯。\n */\n`;
  proxyContent += handleApiCallFunctionContent;
  proxyContent += `export const apiProxy = {\n`;

  for (const endpoint of endpoints) {
    const fullPath = endpoint.path;
    if (!fullPath.startsWith("/api/")) continue;

    const endpointBase = fullPath.substring("/api/".length);

    for (const method of endpoint.methods) {
      const httpMethod = method.toLowerCase();
      if (httpMethod === "options") continue;

      const jsDocKey = `${httpMethod} ${fullPath}`;
      const customJsDoc = routeDocsMap[jsDocKey] ?? null;

      const currentProxyMethodName = endpointBase
        .split("/")
        .filter(segment => !segment.startsWith(':'))
        .map((segment, index) => {
          if (index === 0) return segment;
          return segment.charAt(0).toUpperCase() + segment.slice(1);
        })
        .join("")
        .replace(/-([a-z])/g, (g) => g[1].toUpperCase());

      let jsdocString = '    /**\n';
      if (customJsDoc) {
        const cleanedDoc = customJsDoc
          .replace('/**', '')
          .replace('*/', '')
          .trim()
          .split('\n')
          .map(line => `     *${line.trim() ? ' ' + line.trim().replace(/^\*/, '').trim() : ''}`)
          .join('\n');
        jsdocString += `${cleanedDoc}\n`;
      } else {
        jsdocString += `     * 呼叫 ${httpMethod.toUpperCase()} ${fullPath} API。\n`;
      }
      jsdocString += '     */';

      let paramsDeclaration = "";
      let functionBodyContent = "";
      const pathParams = (fullPath.match(/:(\w+)/g) || []).map((p) => p.substring(1));

      if (httpMethod === "get" || httpMethod === "delete") {
        if (pathParams.length > 0) paramsDeclaration = pathParams.join(", ");
        if (paramsDeclaration) paramsDeclaration += ", ";
        paramsDeclaration += "queryParams = {}, accept = null";
        const endpointPathEvaluated = endpointBase.replace(/:(\w+)/g, (_, p) => `\${${p}}`);
        functionBodyContent = `        const endpoint = \`${endpointPathEvaluated}\`;\n`;
        functionBodyContent += `        return handleApiCall(api.${httpMethod}, endpoint, null, queryParams, accept);\n`;
      } else {
        paramsDeclaration = "data, queryParams = {}, accept = null";
        functionBodyContent = `        const endpoint = '${endpointBase}';\n`;
        functionBodyContent += `        return handleApiCall(api.${httpMethod}, endpoint, data, queryParams, accept);\n`;
      }

      proxyContent += `\n${jsdocString}\n`;
      proxyContent += `    ${currentProxyMethodName}: async (${paramsDeclaration}) => {\n`;
      proxyContent += functionBodyContent;
      proxyContent += `    },\n`;
    }
  }

  proxyContent += `};\n`;

  try {
    await Deno.writeTextFile(OUTPUT_PATH, proxyContent);
    console.log(`[API Proxy 生成器] ${OUTPUT_PATH} 已成功生成。`);
  } catch (e) {
    console.error(`[API Proxy 生成器] 寫入檔案失敗:`, e);
  }
}
